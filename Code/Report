Intro and methodolgy:
The travelling salesman problem is a classical combinatorial optimization problem. The research on the exact algorithm for travelling salesman problem is significant not only because the research has sufficient practical significance. Until now, researchers have not found a polynomial time algorithm for the travelling salesman problem. Among the existing algorithms, the brute force algorithm can solve the problem in time O(n2·2n) where n is the number of nodes in the graph. 
The Algorithm used will use concepts of recursion to find the next path from one to point to another. It will also store all the distances of the subpaths. This will be beneficial when the program comes across the same path later on the program and can retrieve previous data that will save time instead of another run through the program. The result is expected to consume a large amount of memory but will have a more efficient time complexity in comparison to other factorial methods of O(n!), which can grow infinitely large. In this paper, a new exact algorithm for traveling salesman problem is proposed. The algorithm can be used to solve an arbitrary instance of traveling salesman problem in real life, namely, the algorithm is a general exact algorithm for traveling salesman problem in real life. 

Firstly, the algorithm chooses a node of the graph as the source node. Then the source transmits information to every other node. In the algorithm, every piece of information travels at the same speed ,or the same step, and along the shortest path between the information transmission node and the destination node. Meanwhile, each piece of information records the number and traversal sequence of the nodes it has traveled in the process of information transfer and computes the total traveling distance in the traveling process. When a piece of information arrives at the destination node, the information will be retransmitted to every node which the information has not traveled if the information is the first arriving information among the all the pieces of information which have traveled the same node set. If a piece of information has traveled all the nodes in the graph, it will be retransmitted back to the source node and the first returning information will bring back the shortest circle traversal sequence which the algorithm intends to search if the graph is connected. This is because every piece of information travels at the same speed. Therefore, when the algorithm finds that a piece of information returns to the start node or there is no more information to transmit and receive in the node system of the graph G if graph G is disconnected, the algorithm terminates.  

Problem description:
The traveling salesman problem can be simply described as follows: given a finite number of “cities” along with the cost of travel between each pair of them, find the cheapest way of visiting all of the cities and returning to the starting point. The travel costs are symmetric in the sense that traveling from city X to city Y costs just as much as traveling from Y to X [Applegate et al. 1998]. If we describe traveling salesman problem based on the concepts of graph theory, the problem can be stated as follows: for an undirected graph G=(V,E), where V is the set of nodes and E is the set of edges. The weight of its edge (i, j)  E is Wij which represents the length or
cost of the edge(i,j)E. In practical problems, the travel cost of arbitrary two adjacent cities is positive, namely, Wij >0 ( (i, j)  E ).We use Pij to represent the shortest traversal distance between node vi and vj ( vi ,vj V ) and use Pmin to
represent the minimum Pij in graph G. In reality, Pmin is equal to Wmin which represents the shortest edge weight in graph G.
Definition 1 (circle traversal sequence). For an undirected graph G=(V,E) whose start node is v0, a circle traversal sequence of V is a traversal sequence which starts and ends with start node v0, and includes each node of V. Besides, each node only has one sequence position in a circle traversal sequence except the start node.
